"""
Dominic Morris - Combined Rodeostat & RedPitaya AC/CV Viewer

- Rodeostat: CV/DC/Ramp test with proper voltage & current plotting
- RedPitaya: OUT1 voltage, IN1 voltage, IN1 current (via shunt)
- Live synchronized plotting with continuous measurements
"""

import os
import time
import threading
import numpy as np
import yaml
import matplotlib.pyplot as plt
import serial.tools.list_ports
import traceback
from pyrpl import Pyrpl
from potentiostat import Potentiostat

# ------------------------- User Parameters -------------------------
COM_PORT = None
RUN_TIME_SEC = 20
MODE = 'CV'  # 'DC', 'RAMP', 'CV'
CURR_RANGE = '1000uA'
SAMPLE_RATE = 100.0  # Lower sample rate for stability
VOLT_MIN = 0.5
VOLT_MAX = 1.0
VOLT_PER_SEC = 0.05  # Slower scan for 20s runtime
NUM_CYCLES = 1
QUIET_TIME = 1  # 1 second quiet time before starting
QUIET_VALUE = 0.5  # Start at lower voltage
SHUNT_R = 10_000  # Ohms

# RedPitaya waveform
HOSTNAME = 'rp-f073ce.local'
YAML_FILE = 'scope_config.yml'
WAVEFORM_FREQ = 1000
WAVEFORM_AMP = 0.5
WAVEFORM_OFFSET = 0.0
TIME_WINDOW = 0.005

# ------------------------- Rodeostat Setup -------------------------
rodeostat_data = {'t': [], 'volt': [], 'curr': [], 'running': False}


def setup_rodeostat():
    global COM_PORT
    ports = serial.tools.list_ports.comports()
    if not ports:
        raise SystemExit("No serial ports found.")

    print("Available COM ports:")
    for i, p in enumerate(ports):
        print(f"{i}: {p.device} - {p.description}")

    if COM_PORT is None:
        choice = int(input("Select port number: "))
        COM_PORT = ports[choice].device

    dev = Potentiostat(COM_PORT)

    try:
        ranges = dev.get_all_curr_range()
    except KeyError:
        print("Unknown hardware variant. Using fallback ranges.")
        dev.hw_variant = 'manual_patch'
        ranges = ['1uA', '10uA', '100uA', '1000uA']
        dev.get_all_curr_range = lambda: ranges

    used_range = CURR_RANGE if CURR_RANGE in ranges else ranges[-1]
    if used_range != CURR_RANGE:
        print(f"Warning: Requested CURR_RANGE {CURR_RANGE} not available. Using {used_range}.")

    dev.set_curr_range(used_range)
    dev.set_sample_rate(SAMPLE_RATE)

    # Clear any stale data in serial buffer
    try:
        dev.dev.reset_input_buffer()
        dev.dev.reset_output_buffer()
        time.sleep(0.1)
        print("Serial buffers cleared")
    except:
        pass

    # Setup cyclic / DC / Ramp
    if MODE.upper() == 'CV':
        volt_min = VOLT_MIN
        volt_max = VOLT_MAX
        num_cycles = NUM_CYCLES
    elif MODE.upper() == 'DC':
        volt_min = VOLT_MIN
        volt_max = volt_min
        num_cycles = max(1, int(RUN_TIME_SEC * SAMPLE_RATE / 1000))
    elif MODE.upper() == 'RAMP':
        volt_min = VOLT_MIN
        volt_max = VOLT_MAX
        num_cycles = 1
    else:
        raise ValueError("Invalid MODE, choose 'DC', 'RAMP', or 'CV'")

    amplitude = (volt_max - volt_min) / 2
    offset = (volt_max + volt_min) / 2
    period_ms = int(1000 * 4 * amplitude / VOLT_PER_SEC) if amplitude != 0 else 1000

    test_param = {
        'quietValue': QUIET_VALUE,
        'quietTime': QUIET_TIME,
        'amplitude': amplitude,
        'offset': offset,
        'period': period_ms,
        'numCycles': num_cycles,
        'shift': 0.0
    }
    dev.set_param('cyclic', test_param)
    return dev


def run_rodeostat(dev, stop_event):
    """Run Rodeostat test and collect data"""
    try:
        rodeostat_data['running'] = True
        print("Starting Rodeostat test...")

        # Run test - this blocks until complete
        t, volt, curr = dev.run_test('cyclic', display='data', filename='rodeostat_data.txt')

        # Check if we got valid data
        if t is None or len(t) == 0:
            print("No data returned from Rodeostat")
            rodeostat_data['running'] = False
            return

        print(f"Received {len(t)} samples from Rodeostat")

        # Convert numpy arrays to lists and store
        rodeostat_data['t'] = [float(x) for x in t]
        rodeostat_data['volt'] = [float(x) for x in volt]
        rodeostat_data['curr'] = [float(x) for x in curr]
        print(f"Stored {len(rodeostat_data['t'])} samples")
        print(f"Voltage range: {min(rodeostat_data['volt']):.3f} to {max(rodeostat_data['volt']):.3f} V")
        print(f"Current range: {min(rodeostat_data['curr']):.1f} to {max(rodeostat_data['curr']):.1f} uA")

        rodeostat_data['running'] = False
        print("Rodeostat test complete")

    except Exception as e:
        print("Rodeostat error:", e)
        traceback.print_exc()
        rodeostat_data['running'] = False


# ------------------------- RedPitaya Setup -------------------------
class RedPitayaScope:
    def __init__(self):
        self.create_yaml()
        self.rp = Pyrpl(modules=['scope', 'asg0'], config=YAML_FILE)
        self.scope = self.rp.rp.scope
        self.asg = self.rp.rp.asg0

        # Configure for continuous mode
        self.scope.input1 = 'in1'
        self.scope.input2 = 'out1'
        self.scope.decimation = 128
        self.scope.duration = TIME_WINDOW
        self.scope.average = False
        self.scope.trigger_source = 'immediately'  # Free-running
        self.scope.running_state = 'running_continuous'  # Continuous mode

        self.sample_rate = 125e6 / self.scope.decimation
        self.setup_output()
        print("üî¥ RedPitaya scope ready (continuous mode)")

    def create_yaml(self):
        if not os.path.exists(YAML_FILE):
            config = {
                'redpitaya_hostname': HOSTNAME,
                'modules': ['scope', 'asg0'],
                'scope': {
                    'ch1_active': True,
                    'ch2_active': True,
                    'input1': 'in1',
                    'input2': 'out1',
                    'threshold': 0.0,
                    'hysteresis': 0.0,
                    'duration': TIME_WINDOW,
                    'trigger_delay': 0.0,
                    'trigger_source': 'immediately',
                    'running_state': 'running_continuous',
                    'average': False,
                    'decimation': 128
                },
                'asg0': {
                    'waveform': 'sin',
                    'frequency': WAVEFORM_FREQ,
                    'amplitude': WAVEFORM_AMP,
                    'offset': WAVEFORM_OFFSET,
                    'output_direct': 'out1',
                    'trigger_source': 'immediately'
                }
            }
            with open(YAML_FILE, 'w') as f:
                yaml.dump(config, f)

    def setup_output(self, freq=None, amp=None, offset=None):
        freq = freq or WAVEFORM_FREQ
        amp = amp or WAVEFORM_AMP
        offset = offset or WAVEFORM_OFFSET
        self.asg.setup(
            waveform='sin',
            frequency=freq,
            amplitude=amp,
            offset=offset,
            output_direct='out1',
            trigger_source='immediately'
        )

    def capture(self):
        """Capture current data in continuous mode"""
        try:
            # Read current buffer (continuous mode automatically updates)
            ch1 = np.array(self.scope._data_ch1)
            ch2 = np.array(self.scope._data_ch2)

            if ch1.size > 0 and ch2.size > 0:
                current = ch1 / SHUNT_R * 1e6  # Convert to uA
                return ch1, ch2, current
            return None, None, None

        except Exception as e:
            print(f"‚ö†Ô∏è RedPitaya capture error: {e}")
            return None, None, None


# ------------------------- Main -------------------------
if __name__ == '__main__':
    stop_event = threading.Event()

    print("=" * 60)
    print("Combined Rodeostat & RedPitaya Measurement System")
    print("=" * 60)

    rodeostat_dev = setup_rodeostat()
    rp_scope = RedPitayaScope()

    # Start Rodeostat in background thread
    rodeostat_thread = threading.Thread(target=run_rodeostat, args=(rodeostat_dev, stop_event))
    rodeostat_thread.start()

    # Setup plots
    plt.ion()
    fig, ax = plt.subplots(3, 2, figsize=(14, 10))
    fig.suptitle(f'{MODE} Test - Live Data', fontsize=14, fontweight='bold')

    start_time = time.time()
    last_update = 0
    plot_counter = 0

    try:
        while time.time() - start_time < RUN_TIME_SEC:
            current_time = time.time() - start_time

            # Update plots at ~10 Hz (reduced from 20 Hz for speed)
            if current_time - last_update < 0.1:
                time.sleep(0.02)
                continue
            last_update = current_time
            plot_counter += 1

            # Only update Rodeostat plots every other frame (5 Hz)
            if rodeostat_data['t'] and len(rodeostat_data['t']) > 0 and plot_counter % 2 == 0:
                if plot_counter == 2:  # Print debug info once
                    print(f"Plotting Rodeostat data: {len(rodeostat_data['t'])} points")
                    print(f"  Time: {rodeostat_data['t'][0]:.3f} to {rodeostat_data['t'][-1]:.3f}")
                    print(f"  Volt: {min(rodeostat_data['volt']):.3f} to {max(rodeostat_data['volt']):.3f}")
                    print(f"  Curr: {min(rodeostat_data['curr']):.1f} to {max(rodeostat_data['curr']):.1f}")

                # Voltage vs Time
                ax[0, 0].clear()
                ax[0, 0].plot(rodeostat_data['t'], rodeostat_data['volt'], 'b-', linewidth=1)
                ax[0, 0].set_ylabel('Voltage (V)', fontweight='bold')
                ax[0, 0].set_title('Rodeostat Voltage')
                ax[0, 0].grid(True, alpha=0.3)
                ax[0, 0].set_xlim([0, max(rodeostat_data['t'])])
                ax[0, 0].set_ylim([min(rodeostat_data['volt']) - 0.05, max(rodeostat_data['volt']) + 0.05])

                # Current vs Time
                ax[1, 0].clear()
                ax[1, 0].plot(rodeostat_data['t'], rodeostat_data['curr'], 'g-', linewidth=1)
                ax[1, 0].set_ylabel('Current (¬µA)', fontweight='bold')
                ax[1, 0].set_title('Rodeostat Current')
                ax[1, 0].grid(True, alpha=0.3)
                ax[1, 0].set_xlim([0, max(rodeostat_data['t'])])
                curr_range = max(rodeostat_data['curr']) - min(rodeostat_data['curr'])
                ax[1, 0].set_ylim([min(rodeostat_data['curr']) - 0.1 * curr_range,
                                   max(rodeostat_data['curr']) + 0.1 * curr_range])

                # IV Curve
                ax[2, 0].clear()
                ax[2, 0].plot(rodeostat_data['volt'], rodeostat_data['curr'], 'r-', linewidth=1)
                ax[2, 0].set_xlabel('Voltage (V)', fontweight='bold')
                ax[2, 0].set_ylabel('Current (¬µA)', fontweight='bold')
                ax[2, 0].set_title('IV Curve')
                ax[2, 0].grid(True, alpha=0.3)
                ax[2, 0].set_xlim([min(rodeostat_data['volt']) - 0.05, max(rodeostat_data['volt']) + 0.05])
                ax[2, 0].set_ylim([min(rodeostat_data['curr']) - 0.1 * curr_range,
                                   max(rodeostat_data['curr']) + 0.1 * curr_range])

            # Always update RedPitaya plots (right column)
            ch_in, ch_out, current = rp_scope.capture()
            if ch_in is not None:
                t_vec = np.arange(len(ch_in)) / rp_scope.sample_rate

                # OUT1 Voltage (AC output)
                ax[0, 1].clear()
                ax[0, 1].plot(t_vec * 1000, ch_out, 'orange', linewidth=1)
                ax[0, 1].set_ylabel('Voltage (V)', fontweight='bold')
                ax[0, 1].set_title('RedPitaya OUT1 (AC Signal)')
                ax[0, 1].grid(True, alpha=0.3)

                # IN1 Voltage
                ax[1, 1].clear()
                ax[1, 1].plot(t_vec * 1000, ch_in, 'tab:blue', linewidth=1)
                ax[1, 1].set_ylabel('Voltage (V)', fontweight='bold')
                ax[1, 1].set_title('RedPitaya IN1')
                ax[1, 1].grid(True, alpha=0.3)

                # Calculated Current via Shunt
                ax[2, 1].clear()
                ax[2, 1].plot(t_vec * 1000, current, 'tab:red', linewidth=1)
                ax[2, 1].set_xlabel('Time (ms)', fontweight='bold')
                ax[2, 1].set_ylabel('Current (¬µA)', fontweight='bold')
                ax[2, 1].set_title(f'IN1 Current (R={SHUNT_R}Œ©)')
                ax[2, 1].grid(True, alpha=0.3)

            plt.tight_layout()
            plt.pause(0.001)

            # Check if Rodeostat finished
            if rodeostat_data['running'] == False and len(rodeostat_data['t']) > 0:
                print("Rodeostat measurement complete")
                # Continue running to show final plots
                if time.time() - start_time > RUN_TIME_SEC:
                    break

    except KeyboardInterrupt:
        print("\nAcquisition stopped by user")
    finally:
        stop_event.set()
        rodeostat_thread.join(timeout=2)
        plt.ioff()

        print("\n" + "=" * 60)
        print("Measurement Complete!")
        print(f"Rodeostat samples: {len(rodeostat_data['t'])}")
        print("=" * 60)

        plt.show()
