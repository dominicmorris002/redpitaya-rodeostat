"""
Dominic Morris - Combined Rodeostat & RedPitaya AC/CV Viewer

- Runs Rodeostat CV / DC / Ramp tests
- Captures RedPitaya IN1/OUT1 waveform continuously
- Calculates current from IN1 using 10kŒ© shunt
- Plots voltage & current overlay with phase difference
- Separate plot for OUT1 voltage
"""

import os
import time
import numpy as np
import yaml
import matplotlib.pyplot as plt
import serial.tools.list_ports
import traceback
from pyrpl import Pyrpl
from potentiostat import Potentiostat

# ------------------------- Rodeostat Parameters -------------------------
MODE = 'CV'  # Options: 'DC', 'RAMP', 'CV'
CURR_RANGE = '1000uA'
SAMPLE_RATE = 1000.0  # Hz
QUIET_TIME = 0
QUIET_VALUE = 0.0

# DC / Ramp settings
V_START = 1
V_END = 0.8
DC_RUNTIME = 30  # seconds

# CV settings
VOLT_MIN = 0.5
VOLT_MAX = 1.0
VOLT_PER_SEC = 0.10
NUM_CYCLES = 1

SHUNT_R = 10_000  # Ohms for IN1 -> current calculation

# ------------------------- RedPitaya Parameters -------------------------
HOSTNAME = 'rp-f073ce.local'
OUTPUT_DIR = 'scope_data'
YAML_FILE = 'scope_config.yml'
WAVEFORM_FREQ = 1000
WAVEFORM_AMP = 0.5
WAVEFORM_OFFSET = 0.0
TIME_WINDOW = 0.005

# ------------------------- Setup Rodeostat -------------------------
ports = serial.tools.list_ports.comports()
if not ports:
    raise SystemExit("No serial ports found. Connect your Rodeostat.")

print("Available COM ports:")
for i, p in enumerate(ports):
    print(f"{i}: {p.device} - {p.description}")
choice = int(input("Select port number: "))
port = ports[choice].device
print("Using port:", port)

datafile = 'data.txt'

# Convert mode to cyclic parameters
if MODE.upper() == 'CV':
    volt_min = VOLT_MIN
    volt_max = VOLT_MAX
    num_cycles = NUM_CYCLES
elif MODE.upper() == 'DC':
    volt_min = V_START
    volt_max = V_START
    try:
        DC_RUNTIME = float(input("Enter DC test runtime in seconds: "))
    except:
        DC_RUNTIME = 10
    amplitude = 0
    offset = V_START
    period_ms = 1000
    num_cycles = max(1, int(DC_RUNTIME * 1000 / period_ms))
elif MODE.upper() == 'RAMP':
    volt_min = V_START
    volt_max = V_END
    num_cycles = 1
else:
    raise ValueError("Invalid MODE, choose 'DC', 'RAMP', or 'CV'")

if MODE.upper() != 'DC':
    amplitude = (volt_max - volt_min) / 2
    offset = (volt_max + volt_min) / 2
    period_ms = int(1000 * 4 * amplitude / VOLT_PER_SEC) if amplitude != 0 else 1000

shift = 0.0
test_param = {
    'quietValue': QUIET_VALUE,
    'quietTime': QUIET_TIME,
    'amplitude': amplitude,
    'offset': offset,
    'period': period_ms,
    'numCycles': num_cycles,
    'shift': shift
}

# Create Rodeostat device
dev = Potentiostat(port)

# Detect and fix current range for unknown firmware
try:
    ranges = dev.get_all_curr_range()
except KeyError:
    print("Unknown firmware. Using fallback ranges.")
    dev.hw_variant = 'manual_patch'
    ranges = ['1uA', '10uA', '100uA', '1000uA']
    dev.get_all_curr_range = lambda: ranges

if CURR_RANGE not in ranges:
    print(f"Warning: CURR_RANGE {CURR_RANGE} not available. Using {ranges[-1]}")
    CURR_RANGE = ranges[-1]

try:
    dev.set_curr_range(CURR_RANGE)
    dev.set_sample_rate(SAMPLE_RATE)
    dev.set_param('cyclic', test_param)
except Exception as e:
    print("Error configuring Rodeostat:", e)
    traceback.print_exc()
    raise SystemExit

print(f"Running {MODE.upper()} test (using cyclic waveform)...")
try:
    t, volt, curr = dev.run_test('cyclic', display='data', filename=datafile)
except Exception as e:
    print("Error running Rodeostat test:", e)
    traceback.print_exc()
    raise SystemExit
print("Rodeostat test complete. Data saved to", datafile)

# ------------------------- Setup RedPitaya Scope -------------------------
class RedPitayaScope:
    def __init__(self, hostname=HOSTNAME, output_dir=OUTPUT_DIR, yaml_file=YAML_FILE):
        self.output_dir = output_dir
        self.yaml_file = yaml_file
        self.create_yaml()
        self.rp = Pyrpl(modules=['scope', 'asg0'], config=self.yaml_file)
        self.scope = self.rp.rp.scope
        self.asg = self.rp.rp.asg0
        self.scope.input1 = 'in1'
        self.scope.input2 = 'out1'
        self.scope.decimation = 128
        self.scope.duration = 0.01
        self.scope.average = False
        self.scope.trigger_mode = 'auto'
        self.scope.setup()
        self.sample_rate = 125e6 / self.scope.decimation
        self.test_freq = WAVEFORM_FREQ
        self.test_amp = WAVEFORM_AMP
        self.test_offset = WAVEFORM_OFFSET
        self.setup_output()

    def create_yaml(self):
        if not os.path.exists(self.yaml_file):
            config = {
                'redpitaya_hostname': HOSTNAME,
                'modules': ['scope', 'asg0'],
                'scope': {
                    'ch1_active': True,
                    'ch2_active': True,
                    'input1': 'in1',
                    'input2': 'out1',
                    'threshold': 0.0,
                    'hysteresis': 0.0,
                    'duration': 0.01,
                    'trigger_delay': 0.0,
                    'trigger_source': 'ch1_positive_edge',
                    'trigger_mode': 'auto',
                    'average': False,
                    'decimation': 128
                },
                'asg0': {
                    'waveform': 'sin',
                    'frequency': WAVEFORM_FREQ,
                    'amplitude': WAVEFORM_AMP,
                    'offset': WAVEFORM_OFFSET,
                    'output_direct': 'out1',
                    'trigger_source': 'immediately'
                }
            }
            with open(self.yaml_file, 'w') as f:
                yaml.dump(config, f)
            print(f"Created YAML: {self.yaml_file}")
        else:
            print(f"YAML exists: {self.yaml_file}")

    def setup_output(self, freq=None, amp=None, offset=None):
        if freq is not None: self.test_freq = freq
        if amp is not None: self.test_amp = amp
        if offset is not None: self.test_offset = offset
        self.asg.setup(
            waveform='sin',
            frequency=self.test_freq,
            amplitude=self.test_amp,
            offset=self.test_offset,
            output_direct='out1',
            trigger_source='immediately'
        )
        print(f"üîä Output: {self.test_freq} Hz, {self.test_amp} V, Offset: {self.test_offset} V")

    def capture(self, timeout=1.0):
        try:
            self.scope.single()
            dt = 0.01
            elapsed = 0
            while elapsed < timeout:
                ch1 = np.array(self.scope._data_ch1_current)
                ch2 = np.array(self.scope._data_ch2_current)
                if ch1.size > 0 and ch2.size > 0:
                    return ch1, ch2
                time.sleep(dt)
                elapsed += dt
        except Exception as e:
            print("‚ö†Ô∏è Error during capture:", e)
        print("Acquisition timed out")
        return None, None

    def plot_time(self, ch_in, ch_out, ax1=None, ax2=None):
        t = np.arange(len(ch_in)) / self.sample_rate
        ch_current = ch_in / SHUNT_R * 1e6  # Convert voltage to uA

        # Phase difference at dominant frequency
        N = len(ch_in)
        fft_in = np.fft.rfft(ch_in * np.hanning(N))
        fft_out = np.fft.rfft(ch_out * np.hanning(N))
        peak_idx = np.argmax(np.abs(fft_in))
        phase_diff_deg = np.degrees(np.angle(fft_out[peak_idx]) - np.angle(fft_in[peak_idx]))

        # Overlay voltage & current on ax1
        if ax1 is None:
            plt.figure(figsize=(12, 6))
            ax1 = plt.subplot(211)
            ax2 = plt.subplot(212)
        ax1.clear()
        ax1.plot(t, ch_in, label='IN1 Voltage', color='tab:blue')
        ax1.plot(t, ch_current, label='IN1 Current (uA)', color='tab:red')
        ax1.set_ylabel('Voltage / Current')
        ax1.set_title(f'IN1 Voltage & Current ‚Äî Phase: {phase_diff_deg:.1f}¬∞')
        ax1.grid(True)
        ax1.legend()

        ax2.clear()
        ax2.plot(t, ch_out, label='OUT1 Voltage', color='tab:orange')
        ax2.set_ylabel('Voltage (V)')
        ax2.set_xlabel('Time (s)')
        ax2.set_title('OUT1 Voltage')
        ax2.grid(True)
        ax2.legend()
        plt.pause(0.001)

    def run_continuous(self):
        print("Starting RedPitaya capture. Press Ctrl+C to stop.")
        plt.ion()
        fig, ax = plt.subplots(2, 1, figsize=(12, 6))
        try:
            while True:
                ch_in, ch_out = self.capture(timeout=0.05)
                if ch_in is None or ch_out is None:
                    time.sleep(0.01)
                    continue
                self.plot_time(ch_in, ch_out, ax1=ax[0], ax2=ax[1])
                time.sleep(0.01)
        except KeyboardInterrupt:
            print("Stopped RedPitaya capture.")
            plt.ioff()
            plt.show()

# ------------------------- Run Everything -------------------------
if __name__ == '__main__':
    # Plot Rodeostat results first
    plt.figure(1)
    plt.subplot(211)
    plt.plot(t, volt, label='Voltage')
    plt.ylabel('Voltage (V)')
    plt.grid(True)
    plt.subplot(212)
    plt.plot(t, curr, label='Current')
    plt.ylabel('Current (uA)')
    plt.xlabel('Time (s)')
    plt.grid(True)
    plt.tight_layout()
    plt.show(block=False)

    plt.figure(2)
    plt.plot(volt, curr)
    plt.xlabel('Voltage (V)')
    plt.ylabel('Current (uA)')
    plt.title(f'{MODE.upper()} Test')
    plt.grid(True)
    plt.tight_layout()
    plt.show(block=False)

    # Start RedPitaya continuous capture
    rp_scope = RedPitayaScope()
    rp_scope.setup_output(freq=WAVEFORM_FREQ, amp=WAVEFORM_AMP, offset=WAVEFORM_OFFSET)
    rp_scope.run_continuous()
